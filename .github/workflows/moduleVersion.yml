# This workflow increments the build version of changed PS modules files in the associated PR

name: Increment Module Versions and Zip Changed Modules

# Controls when the workflow will run
on:
  pull_request:
    branches: [ "main" ]

jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - id: files
        uses: jitterbit/get-changed-files@v1
        continue-on-error: true
        with:
          format: json

      # Runs a set of commands using the runners shell
      - name: Increment changed module versions
        id: module_versions
        run: |
          # Automatically increment the 'build' version numbers on a PS module file
          
          $files = '${{ steps.files.outputs.modified }}' | ConvertFrom-Json
          
          $moduleVersionRegex = [regex]"(?:ModuleVersion\s?=\s?')([\d\.]*)'" 

          $moduleChangedFileList = $files | where-object { $_ -match '\.psm1$'}

          ForEach ($moduleChangedFile in $moduleChangedFileList) {

              try {
                $moduleManifestPath = Get-Item -Path ($moduleChangedFile -replace '\.psm1$','.psd1') -ErrorAction Stop
              }
              catch {
                Write-Error "Error locating .psd1 file for module '$moduleChangedFile'. This file should reside in the same directory as the psm1."
              }
              
              $moduleManifest = Get-Item $moduleManifestPath
              $content = Get-Content $moduleManifest

              If ($moduleVersionMatches = $moduleVersionRegex.matches($content)) {
                  If ($moduleVersionMatches.count -eq 1) {
                      $moduleVersionLine = $moduleVersionMatches[0].Groups[0].Value
                      $currentModuleVersion = $moduleVersionMatches[0].Groups[1].Value

                      If ($version = $currentModuleVersion -as [version]) {
                          $major = $version.Major
                          $minor = $version.Minor
                          $build = $version.Build + 1 # add 1 to current version build number

                          $newVersion = [version]::new($major,$minor,$build)
                      }
                      Else {
                          Write-Error "Version string '$currentModuleVersion' cannot be converted to type [Version]. File: '$moduleManifest'"
                      }

                      $newVersionLine = $moduleVersionLine -replace $currentModuleVersion,$newVersion

                      $moduleManifest | Set-Content -Value ($content -replace $moduleVersionLine,$newVersionLine)
                  }
                  Else {
                      Write-Error "More than one matches for regex '$moduleVersionRegex' found in file '$moduleManifest'"
                  }
              }
          }

          # output whether modules were changed
          If ($moduleChangedFileList.count -eq 0) {
            Write-Host "::set-output name=versions_changed::$($false)"
          }
          Else {
             Write-Host "::set-output name=versions_changed::$($true)"
          }
        shell: pwsh

      - name: Zip updated modules
        id: zip_modules
        run: |
          Write-Host "Executing powershell script in '$pwd'"
          
          $files = '${{ steps.files.outputs.modified }}' | ConvertFrom-Json
          Write-Host "Total '$($files.count)' files changed in last commit"

          $changedModuleManifestFiles = $files | Where-Object {$_ -like '*.psm1'}
          Write-Host "'$($changedModuleManifestFiles.count)' module manifest files changed in last commit"

          try {
            $changedModuleManifestFilesObjs = @()

            ForEach ($file in $changedModuleManifestFiles) {
              $changedModuleManifestFilesObjs += Get-Item -Path $file -ErrorAction Stop
            }
          }
          catch {
            Write-Error "Failed to find file path '$file' with Get-Item -Path $file"
          }

          $zipsChanged = $false
          ForEach ($moduleManifest in $changedModuleManifestFilesObjs) {
              $moduleCodeFile = Get-Item -Path $moduleManifest.FullName.replace('psd1','psm1')
              
              If ($changedModuleManifestFilesObjs.FullName -icontains $moduleManifest.FullName -or $changedModuleManifestFilesObjs.FullName -icontains $moduleCodeFile.FullName) {
                Write-Host "Module '$($moduleManifest.BaseName)' was changed, zipping module files..."

                $destPath = "./psmodules/$($moduleManifest.BaseName).zip"
                Compress-Archive -Path "$($moduleManifest.Directory)/*" -DestinationPath $destPath -Update

                $zipsChanged = $true
              }
              Else {
                  Write-Host "Neither the manifest '$($moduleManifest.FullName.toLower())' or script file '$($moduleCodeFile.FullName.ToLower())' for module '$($moduleManifest.BaseName)' was changed, skipping zipping..."
              }
          }

          # output whether modules were changed
          Write-Host "::set-output name=zips_changed::$($zipsChanged)"

        shell: pwsh

      - name: commit changes
        run: |
          If ([boolean]'${{ steps.module_versions.outputs.versions_changed }}' -or [boolean]'${{ steps.zip_modules.outputs.zips_changed }}' ) {
            git branch
            git config --global user.name 'Automated GitHub Action'
            git config --global user.email 'no-reply@github.com'

            git add -A
            git commit -am "incremented changed module versions: $(git log -1 --pretty=%B)"
            git push
          }
        shell: pwsh
